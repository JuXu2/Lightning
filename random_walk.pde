/**
 * PROGRAMMING VIDEO COMING SOON!
 * 
 * middle-square algorithm challenge!
 * 
 * Goal: improve the middleSquares algorithm
 * Hint: increase the period of the blue line
 * (period = length before repeating)
 * 
 * blue line  - generated by middleSquares() algorithm
 * white line - generated by repeated calls to random() 
 */
 
/* 1. ******PLAY******
The initial 'seed' provided to middleSquares is defined manually here. EXPERIMENT with many values and watch the response! (deterministic & repetitive)
*/

var seed = 19434; // <--- EXPERIMENT HERE try many values!

/* 2. ******THEORY******
middle-squares is completely determined by the initial seed variable. This gives us a repeatable (deterministic) "random looking" sequence.

Remember the length of the seed defines the theoretical limit of the period (time until repeating). The current algorithm is doing a poor job of reaching that limit. 

Notice the pattern often repeats well before it should.
Or, it gets stuck in short cycle and freezes.
for example try: seed = 98823497834979; & seed = 1343

This is insecure for use in cryptography, it must be fixed!
*/

// 3. ******SETUP******
background(0, 0, 0);
// here we set the starting point of random walk
var fromX = 200;
var fromX2 = 200;
// starting point of pseudorandom walk
var fromY = 200;
var fromY2 = 200;
// crop corners of drawspace
var minNum = 0.5;
var maxNum = 475;

/**
 * FUNCTION: middleSquares
 * middleSquare function takes 'seed' as input
 */
var middleSquare = function( seed ) { 

    // variable oldSeed stores the initial seed
    var oldSeed = seed.toString();
    // variable newSeed holds the updated seed
    var newSeed; 
    // compute seed*seed and store in newSeed
    newSeed = (seed * seed).toString();
    
    // make sure newSeed length = oldSeed length
    // loop until newSeed.length = oldSeed.length
    while (newSeed.length < oldSeed.length * 2) {
        // add '1' to the front of newSeed 
        newSeed = '1' + newSeed;
    }
    
    // find the middle digits of newSeed 
    // starting point
    var begin = floor((newSeed.length-oldSeed.length)/2);
    // ending point
    var end = begin + oldSeed.length;
    // return the middle of newSeed
    return newSeed.slice(begin, end);
    
    // end of function
};

// 4. ******FUNCTION: draw******
// draw both walks using draw function.
// you can ignore this at first if you want to only work
// on the algorithm above (skip to 5.)
/**
 * FUNCTION: draw
 * this function is called repeatadly (animation loop)
 */
var draw = function() {
    
    // this variable will change the speed of walking
    var speed = 20; // <---- change speed
    
    // loop defines how long until refresh
    // can this be done a better way?
    for ( var i = 1; i <= speed; i += 1 ) {   
        
        // 1. Draw white line (random walk)    
        
        // A. set the color of the random walk
        stroke(255, 255, 255);
        
        // each step is defined by (x,y) coordinate
        // B. generate a random horizontal (x) step
        var toX = fromX + [-3, 0, 3][floor(random() * 3)];        
        // random() is called each step
        // [3, 0, 3] scales the size of step
        
        // wrap around edge if too small
        if (toX < minNum) {
      toX = maxNum;
      fromX = maxNum;
    }
        // wrape around edge if too large
    if (toX > maxNum) {
      toX = minNum;
      fromX = minNum;
    }
        // C. generate random vertical (y) step 
        // same as B.
        
        // get random number
    var toY = fromY + [-3, 0, 3][floor(random() * 3)];
        
        //wrap edges
    if (toY < minNum) {
      toY = maxNum;
      fromY = maxNum;
    }
    if (toY > maxNum) {
      toY = minNum;
      fromY = minNum;
    }
        
        // D. draw next step as line
        // (visual fun: change this to an ellipse!)
    line(fromX, fromY, toX, toY);
    fromX = toX;
    fromY = toY;
        
        // 2. Draw blue line (pseudorandom walk)    
        
        // A. set the color 
        stroke(42, 42, 235);
        
        // each step is defined by (x,y) coordinate
        // B. calculate the x coordinate
        
        // we no longer call random() instead we use the
        // value stored in seed.
    var toX2 = fromX2 + [-3, 0, 3][seed % 3];
        
        // send seed value to middleSquare function and
        // update it's value for next horizontal step. 
    seed = middleSquare(seed);
        
        // wrap
    if (toX2 < minNum) {
      toX2 = maxNum;
      fromX2 = maxNum;
    }
    if (toX2 > maxNum) {
      toX2 = minNum;
      fromX2 = minNum;
    }
        
        // C: calculate the y coordinate (same as x)
        var toY2 = fromY2 + [-3, 0, 3][seed % 3];
        
        seed = middleSquare(seed);
        
    if (toY2 < minNum) {
      toY2 = maxNum;
      fromY2 = maxNum;
    }
    if (toY2 > maxNum) {
      toY2 = minNum;
      fromY2 = minNum;
    }
        
        // D. draw next step as line
        line(fromX2, fromY2, toX2, toY2);
        
        // update step to new position
        fromX2 = toX2;
    fromY2 = toY2;
        
  } // end of for loop
}; // end of function
